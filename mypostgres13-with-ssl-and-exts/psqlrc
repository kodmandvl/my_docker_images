-- begin of file --
--\set PROMPT1 = '%# '
--\set PROMPT1 = '%n@%/%# '
--\set PROMPT1 = '%n@%M:%>/%/%# '
\set PROMPT1 '%n@%M:%>/%/%R%x%# '
\set PROMPT2 '%n@%M:%>/%/%R%x%# '
--\timing on
--\setenv PAGER 'less -XS'
--\setenv PAGER 'cat'
--\set ECHO_HIDDEN on
--\set AUTOCOMMIT off
--\set HISTFILE /dev/null
\set top5 'SELECT schemaname||''.''||tablename, pg_size_pretty(pg_total_relation_size(schemaname||''.''||tablename)) AS size, pg_total_relation_size(schemaname||''.''||tablename) as bytes FROM pg_tables ORDER BY bytes DESC LIMIT 5;'
\set ver 'select version();'
\set now 'select now();'
\set loc 'select name, setting from pg_settings where name in (''config_file'',''data_directory'',''hba_file'',''ident_file'',''log_directory'',''log_filename'',''port'') order by 1;'
\set uptime 'SELECT now() AS NOW, pg_postmaster_start_time() AS STARTUP_TIME, now() - pg_postmaster_start_time() AS UPTIME;'
\set ts 'SELECT t.spcname as tablespace_name, t.spcowner::regrole as owner, pg_catalog.pg_tablespace_location(oid) as location, spcacl, spcoptions, pg_size_pretty(pg_tablespace_size(t.spcname)) as size FROM pg_tablespace t order by 1;'
\set ext 'select extname as extension_name, extowner::regrole as owner, extnamespace::regnamespace as schema, extversion as version from pg_extension order by 1;'
\set ext_avail 'select name, comment from pg_available_extensions order by 1;'
\set db 'select d.datname, d.datdba::regrole as owner, t.spcname as tablespace_name, d.datistemplate, d.datallowconn, d.datconnlimit, d.datacl, pg_size_pretty(pg_database_size(d.datname)) as size from pg_database d left outer join pg_tablespace t on d.dattablespace=t.oid order by 1;'
\set role 'SELECT CASE WHEN NOT pg_is_in_recovery() THEN ''LEADER'' ELSE ''STANDBY'' END AS ROLE;'
\set lag 'SELECT CASE WHEN NOT pg_is_in_recovery() THEN ''LEADER'' ELSE ''STANDBY'' END AS ROLE, CASE WHEN NOT pg_is_in_recovery() THEN 0 ELSE GREATEST (0, EXTRACT(EPOCH FROM (now() - pg_last_xact_replay_timestamp()))) END AS LAG;'
\set ssl 'SELECT datname, usename, ssl, client_addr, client_dn, issuer_dn FROM pg_stat_ssl JOIN pg_stat_activity ON pg_stat_ssl.pid = pg_stat_activity.pid where ssl=true order by 3 desc, 1, 2, 4;'
\set hba 'select * from pg_hba_file_rules;'
\set members 'select m.roleid::regrole, m.member::regrole, m.grantor::regrole, m.admin_option from pg_auth_members m order by 2, 1;'
\set size 'select pg_size_pretty(sum(pg_database_size(datname))) as sum_db_size from pg_database;'
\set sts 'select s.userid::regrole, d.datname, s.total_exec_time/1000 as total_exec_time_sec, s.mean_exec_time/1000 as mean_exec_time_sec, s.calls, s.* from pg_stat_statements s join pg_database d on s.dbid=d.oid order by s.total_exec_time desc;'
\set sts_reset 'select pg_stat_statements_reset();'
\set std 'select d.* from pg_stat_database d order by d.blks_read desc;'
\set stt 'select t.* from pg_stat_all_tables t order by t.seq_tup_read desc;'
\set sti 'select i.* from pg_stat_all_indexes i order by idx_tup_read desc;'
\set sta 'select a.* from pg_stat_activity a order by a.datname, a.usename;'
\set stag 'select count(*) connections, datname, usename, application_name, client_addr, client_hostname, backend_type from pg_stat_activity group by datname, usename, application_name, client_addr, client_hostname, backend_type order by 1 desc, 2,3,4;'
\set set 'select name, setting, unit from pg_settings order by 1;'
\set pend 'select name,setting from pg_settings where pending_restart=true;'
\set setf 'select name, setting, unit, sourcefile from pg_settings where sourcefile is not null order by sourcefile, name;'
\set reload 'select pg_reload_conf();'
\set str 'select * from pg_stat_replication;'
\set slots 'select * from pg_replication_slots;'
-- end of file --
